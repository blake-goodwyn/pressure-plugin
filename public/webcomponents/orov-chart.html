<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../orov-behaviors/orov-behavior.html">
<dom-module id="orov-chart">
    <style>
        .content-container,
        #chart {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            right: 0;
        }
        
        .line {
            fill: none;
            stroke-width: 0.25vh;
            stroke: #30609B;
        }
        
        .table {
            position: absolute;
            top: 30%;
            transform: translateY(-50%) translateX(-50%);
            left: 80%;
            font-size: 2.5vmax;
            font-weight: 300;
            text-anchor: end;
        }

        .label{
            text-align: right;
            padding-right:1.25vw;
        }

        .tick text {
            font-size: 1vw;
            fill: #2d2d2a;
        }
        
        .domain {
            fill: #C0C0C0;
        }
    </style>
    <template>
		<div class="content-container">
			<content>
			<table class="table">
                <tr>
                    <td class="label">Depth:</td>
                    <td>{{value}} m</td>
                </tr>
                <tr>
                    <td class="label">Pressure:</td>
                    <td>{{pressure}} psi</td>
                </tr>
                <tr>
                    <td class="label">Time:</td>
                    <td>{{dispTime}}</td>
                </tr>
            </table>
            <div id="chart">
            </div>
			</content>
		</div>
	</template>
    <script>
        Polymer({
            is: 'orov-chart',
            properties: {
                value: {
                    Type: Number
                },
                pressure: {
                    Type: Number
                },
                startTime: {
                    Type: Number
                },
                dispTime: {
                    Type: Number
                },
                type: {
                    Type: String,
                    notify: true
                },
                tick: {
                    Type: Number,
                    value: 40,
                    observer: 'tickChanged'
                },
                width: Number,
                height: {
                    type: Number,
                    value: 400
                },
                max: Number,
                inverted: {
                    Type: Boolean,
                    value: false
                },
                data: Array,
                output: Object,
            },
            behaviors: [namespace('behaviors').oROVStandard],
            registerEmitterHanlders: function(emitter) {
                var self = this;
                emitter.on('plugin.engineering.data', function(data) {
                    if (data[self.type]) {
                        self.dataChanged(parseFloat(data[self.type]));
                        self.lastData = data[self.type];
                    }
                });
            },
            dataChanged: function(val) {
                if (!this.data) this.data = [];

                if (/^-?[0-9]+$/.test(val)) {
                    this.value = val;
                } else {
                    this.value = parseFloat(val).toFixed(2);
                };

                this.pressure = parseFloat((val * 1000 * 9.8 * 1.45e-4)).toFixed(2);
                //pressure conversion (Depth*Density*Gravity*[psi/Pa])

                this.data.push(val);

                if (this.drawFlag) {
                    this.draw();
                };
            },

            draw: function() {
                var self = this;
                if (!this.data) {
                    return;
                }

                //obtain current data
                self.curPt = self.data[self.data.length-1]; //raw datastream

                //structure current time output
                self.curTime = parseFloat(Math.floor(Date.now() - self.startTime)/1000).toFixed(1);
                self.dispTime = self.timeFormat(self.curTime, 1);

                if (!self.prevTime) {
                    self.prevTime = self.curTime;
                }; //datastream threshold (.toFixed(1) ==> 10Hz max)

                if ((self.prevTime != self.curTime) || (self.output.length == 0)) {
                    self.output.push({
                        "time": self.curTime,
                        "depth": (self.curPt).toFixed(2),
                        "pressure": self.pressure
                    });
                    self.prevTime = self.curTime;
                    if(self.curPt > self.max){self.max = self.curPt;};
                };

                //obtain current widget dimensions
                self.width = self.elem.offsetWidth;
                self.height = self.elem.offsetHeight;
                self.padding = 0.1;

                //update axes and path
                self.x.range([0.5*self.padding * self.width, (1 - 4 * self.padding) * self.width]);
                self.y.range([(1 - self.padding) * self.height, 2 * self.padding * self.height]);
                self.x.domain([0, self.curTime]);
                self.y.domain([0.01, d3.max([1.5, 1.05 * self.max])]);
                self.path.datum(self.output).transition().duration(100).ease("linear").attr("d", self.line);

                //translate and transition
                if ((!self.yChart) || (!self.xChart)) { //no defined axes

                    self.yChart = self.svg.append("g")  //y axis
                        .attr("class", "y axis")
                        .attr("transform", "translate(" + 0.5*self.padding * self.width + ",0)")
                        .call(self.yAxis);

                    self.xChart = self.svg.append("g") //x axis
                        .attr("class", "x axis")
                        .attr("transform", "translate(0," + (1 - self.padding) * self.height + ")")
                        .call(self.xAxis);

                   self.plotter = self.svg.append("path")  //plotter arrow
                        .attr("d", "M 0 48 L 48 32 L 0 16 L 16 32 z")
                        .attr("transform","translate(" +(self.x(self.curTime) - 6) + "," + (self.y(self.output[self.output.length-1]["depth"]) - 12) +")scale(0.375)")
                        .style("fill","red");

                    //This is where you will insert the gridlines

                } else { //scale transitions
                    self.svg.select(".x.axis")
                        .attr("transform", "translate(0," + (1 - self.padding) * self.height + ")")
                        .transition()
                        .duration(100)
                        .ease("linear")
                        .call(self.xAxis);

                    self.svg.select(".y.axis")
                        .attr("transform", "translate(" + 0.5*self.padding * self.width + ",0)")
                        .transition()
                        .duration(100)
                        .ease("linear")
                        .call(self.yAxis);

                    self.plotter
                        .attr("transform","translate(" +(self.x(self.curTime) - 6) + "," + (self.y(self.output[self.output.length-1]["depth"]) - 12) +")scale(0.375)");

                    //This is where you will update the gridlines
            
                }
            },

            ready: function() {

                if (!this.data) this.data = [];

                this.elem = this.$.chart;
                var self = this;
                self.width = self.$.chart.clientWidth;
                self.height = self.$.chart.clientHeight;
                self.drawFlag = false;
                self.buttonX = "68%";
                self.textX = "80.5%";
                self.max = -Infinity;

                self.x = d3.scale.linear();
                self.y = d3.scale.linear();

                self.line = d3.svg.line()
                    .x(function(d) {
                        return self.x(d["time"]);
                    })
                    .y(function(d) {
                        return self.y(d["depth"]);
                    })
                    .interpolate("basis");

                self.timeFormat = function(time,dec) { //curTime => dispTime
                    var dec = (typeof dec !== 'undefined') ?  dec : 0; //default fixed pt parameter
                    if (time < 60) {
                        return "00:" + ((time % 60 < 10) ? ("0" + parseFloat(time % 60).toFixed(dec)) : parseFloat(time % 60).toFixed(dec));
                    } else if (self.curTime < 600) {
                        return "0" + Math.floor(time / 60) + ":" + ((time % 60 < 10) ? ("0" + parseFloat(time % 60).toFixed(dec)) : parseFloat(time % 60).toFixed(dec));
                    }else{
                        return Math.floor(time / 60) + ":" + ((time % 60 < 10) ? ("0" + parseFloat(time % 60).toFixed(dec)) : parseFloat(time % 60).toFixed(dec));
                    }
                };

                self.svg = d3.select(self.$.chart).append("svg")
                    .attr("width", '100%')
                    .attr("height", '100%');

                self.imgs = self.svg.selectAll("img").data([0]);

                self.imgs.enter() //logo
                    .append("svg:image")
                    .attr("xlink:href", "components/pressure-plugin/logo.png")
                    .attr("x", "5.5%")
                    .attr("y", "-5%")
                    .attr("width", "30%")
                    .attr("height", "30%");

                //y-axis
                self.yAxis = d3.svg.axis().orient("left").scale(self.y);

                //x-axis
                self.xAxis = d3.svg.axis().orient("bottom").scale(self.x).tickFormat(function(d){return self.timeFormat(d,0);});

                self.path = self.svg.append("g")
                    .attr("clip-path", "url(#clip)")
                    .append("path")
                    .attr("class", "line")
                    .datum([])
                    .attr("d", self.line);

                /*Initialize button stuff here*/
                self.startApp = function() {
                    self.start = self.svg.append("g").attr("id", "start");

                    self.start.append("rect")
                        .attr("x", self.buttonX)
                        .attr("y", "45%")
                        .attr("height", "20%")
                        .attr("width", "25%")
                        .attr("id", "start-rect")
                        .style("fill", "#EFF8FB")
                        .style("stroke", "#2d2d2a")
                        .style("stroke-width", 2);

                    self.start.append("text")
                        .style("text-anchor", "middle")
                        .attr("x", self.textX)
                        .attr("y", "57.5%")
                        .attr("id", "start-text")
                        .text("START")
                        .style("font-size", "4vw")
                        .style("font-weight", "bold");

                    self.start.on("mouseover", function() {
                        self.svg.select("#start-rect")
                            .transition()
                            .duration(100)
                            .ease("cubic")
                            .style("fill", "#81BEF7")
                            .style("stroke-opacity", 0.4);
                        document.body.style.cursor = "pointer";
                    });

                    self.start.on("mouseout", function() {
                        self.svg.select("#start-rect")
                            .transition()
                            .duration(100)
                            .ease("cubic")
                            .style("fill", "#EFF8FB")
                            .style("stroke-opacity", 1.0);
                        document.body.style.cursor = "default";
                    });

                    if(!!self.output && self.output.length > 0){ self.holdup = true;}
                    else{self.holdup = false;}

                    self.start.on("click", function() {

                        var allow = true;
                        if (self.holdup){allow = confirm("A dataset already exists. Continue?")};

                        if (allow){

                            self.start.remove();
                            if (!!self.exp) {
                                self.exp.remove();
                            };
                            self.output = [];
                            self.startTime = Date.now();
                            self.startIdx = self.data.length-1;
                            self.drawFlag = true;

                            self.stop = self.svg.append("g").attr("id", "stop");

                            self.stop.append("rect")
                                .attr("x", self.buttonX)
                                .attr("y", "45%")
                                .attr("height", "20%")
                                .attr("width", "25%")
                                .attr("id", "start-rect")
                                .style("fill", "#EFF8FB")
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            self.stop.append("text")
                                .style("text-anchor", "middle")
                                .attr("x", self.textX)
                                .attr("y", "57.5%")
                                .attr("id", "start-text")
                                .text("STOP")
                                .style("font-size", "4vw")
                                .style("font-weight", "bold");

                            self.stop.on("mouseover", function() {
                                self.svg.select("#start-rect")
                                    .transition()
                                    .duration(100)
                                    .ease("cubic")
                                    .style("fill", "#81BEF7")
                                    .style("stroke-opacity", 0.4);
                                document.body.style.cursor = "pointer";
                            });

                            self.stop.on("mouseout", function() {
                                self.svg.select("#start-rect")
                                    .transition()
                                    .duration(100)
                                    .ease("cubic")
                                    .style("fill", "#EFF8FB")
                                    .style("stroke-opacity", 1.0);
                                document.body.style.cursor = "default";
                            });

                            self.stop.on("click", function() {
                                self.stop.remove();
                                self.drawFlag = false;

                                //Append export button
                                self.exp = self.svg.append("g").attr("id", "export");

                                self.exp.append("rect")
                                    .attr("x", self.buttonX)
                                    .attr("y", "67.5%")
                                    .attr("height", "20%")
                                    .attr("width", "25%")
                                    .attr("id", "exp-rect")
                                    .style("fill", "#EFF8FB")
                                    .style("stroke", "black")
                                    .style("stroke-width", 2);

                                self.exp.append("text")
                                    .style("text-anchor", "middle")
                                    .attr("x", self.textX)
                                    .attr("y", "80%")
                                    .attr("id", "exp-text")
                                    .text("EXPORT")
                                    .style("font-size", "4vw")
                                    .style("font-weight", "bold");

                                self.exp.on("mouseover", function() {
                                    self.svg.select("#exp-rect")
                                        .transition()
                                        .duration(100)
                                        .ease("cubic")
                                        .style("fill", "#81BEF7")
                                        .style("stroke-opacity", 0.4);
                                    document.body.style.cursor = "pointer";
                                });

                                self.exp.on("mouseout", function() {
                                    self.svg.select("#exp-rect")
                                        .transition()
                                        .duration(100)
                                        .ease("cubic")
                                        .style("fill", "#EFF8FB")
                                        .style("stroke-opacity", 1.0);
                                    document.body.style.cursor = "default";
                                });

                                self.exp.on("click", function() {

                                    var name = prompt('What would you like to call this file? (no need to add any extensions!)');
                                    if (!!name) {
                                        download((name + '.csv'), ConvertToCSV(self.output));
                                    };

                                    function ConvertToCSV(objArray) {
                                        var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;
                                        var str = '';

                                        var header = ''; //append header
                                        for (var index in array[0]) {
                                            header += index + ',';
                                        };
                                        str += header + '\r\n';

                                        for (var i = 0; i < array.length; i++) { //append values
                                            var line = '';
                                            for (var index in array[i]) {
                                                if (line != '') {
                                                    line += ','
                                                };
                                                if (index == "time") {
                                                    line += self.timeFormat(array[i][index],1);
                                                } else {
                                                    line += array[i][index];
                                                };
                                            }
                                            str += line + '\r\n';
                                        }
                                        return str;
                                    };

                                    function download(filename, text) {
                                        var pom = document.createElement('a');
                                        pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
                                        pom.setAttribute('download', filename);

                                        if (document.createEvent) {
                                            var event = document.createEvent('MouseEvents');
                                            event.initEvent('click', true, true);
                                            pom.dispatchEvent(event);
                                        } else {
                                            pom.click();
                                        };
                                    };
                                });

                                self.startApp();
                            })
                        }
                    });
                };

                self.startApp();

                window.addEventListener('resize', function() {
                    self.width = self.elem.offsetWidth;
                    self.height = self.elem.offsetHeight;

                    self.x.range([0.5*self.padding * self.width, (1 - 4 * self.padding) * self.width]);
                    self.y.range([(1 - self.padding) * self.height, 2 * self.padding * self.height]);


                    if ((!!self.yChart) && (!!self.xChart)) {
                        self.svg.selectAll(".axis").remove();

                        self.yChart = self.svg.append("g")
                            .attr("class", "y axis")
                            .attr("transform", "translate(" + 0.5*self.padding * self.width + ",0)")
                            .call(self.yAxis);

                        self.xChart = self.svg.append("g")
                            .attr("class", "x axis")
                            .attr("transform", "translate(0," + (1 - self.padding) * self.height + ")")
                            .call(self.xAxis);

                        self.plotter
                            .attr("transform","translate(" +(self.x(self.curTime) - 12) + "," + (self.y(self.output[self.output.length-1]["depth"]) - 24) +")scale(0.75)");
                    };

                    self.path.transition().duration(100).attr("d", self.line);
                }, true);
            }
        });
    </script>
</dom-module>